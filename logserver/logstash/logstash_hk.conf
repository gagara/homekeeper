input {
    http {
        host => "0.0.0.0"
        port => 8085
        response_headers => {"Content-Length" => "0"}
    }
}

# Save original message
filter {
    json {
        source => "message"
    }
}

# Clone and split nsc message to have separate msg for each sensor
filter {
    if ([m] == "nsc") {
        clone {
            clones => [ "clone" ]
            remove_field => [ "m", "id", "ns", "ts", "ff", "ft" ]
        }
        if ([type] == "clone") {
            split {
                field => "s"
                add_field => { "m" => "csr" }
            }
        }
    }
}

# Define csr_type; csr_state='actual'. extract ids and values. extract ts
filter {
    if ([m] == "csr") {
        if ([n]) {
            mutate { add_field => { "csr_type" => "node" "csr_state" => "actual" "id" => "%{[n][id]}" "n_id" => "%{[n][id]}" "n_ns" => "%{[n][ns]}" "ts" => "%{[n][ts]}" } }
            mutate { convert => { "n_id" => "integer" "n_ns" => "integer" "ts" => "integer" } }
        }
        if ([s]) {
            mutate { add_field => { "csr_type" => "sensor" "csr_state" => "actual" "id" => "%{[s][id]}" "s_id" => "%{[s][id]}" "s_v" => "%{[s][v]}" "ts" => "%{[s][ts]}"} }
            mutate { convert => { "s_id" => "integer" "s_v" => "integer" "ts" => "integer" } }
        }
    }
}

# Extract node id and state for nsc message
filter {
    if ([m] == "nsc") {
        mutate { add_field => { "n_id" => "%{[id]}" "n_ns" => "%{[ns]}" } }
        mutate { convert => { "n_id" => "integer" "n_ns" => "integer" } }
    }
}

# Node: extract prev ts, prev state
filter {
    if ([m] == "csr" and [n] and [ts]) {
        elasticsearch {
            hosts => ["elasticsearch:9200"]
            index => "logstash_hk-*"
            query => "m:csr AND n.id:%{[n_id]}"
            fields => { "ts" => "prev_ts_" "n_ns" => "prev_n_ns_" }
        }
        mutate { convert => { "prev_ts_" => "integer" "prev_n_ns_" => "integer" } }
    }
}

# Node: calculate period
filter {
    if ([m] == "csr" and [n] and [ts] and [n_ns] != [prev_n_ns_]) {
        if ([prev_ts_] and [ts] > [prev_ts_]) {
            ruby {
                code => "event.set('period', (event.get('ts') - event.get('prev_ts_'))) rescue nil"
            }
        } else {
            elasticsearch {
                hosts => ["elasticsearch:9200"]
                index => "logstash_hk-*"
                query => "m:csr AND n.id:%{[n_id]} AND n.ns:%{[n_ns]}"
                fields => { "@timestamp" => "prev_timestamp" }
            }
            date {
                match => ["[prev_timestamp]", "ISO8601"]
                target => "[prev_timestamp]"
            }
            ruby {
                code => "event.set('period', event.get('@timestamp') - event.get('prev_timestamp')) rescue nil"
            }
        }
    }
}

# Define sensor_type
filter {
    if ([m] == "csr" and [s]) {
        if ([s_id] == 60) {
            mutate { add_field => { "sensor_type" => "state" } }
        } else {
            mutate { add_field => { "sensor_type" => "value" } }
        }
    }
 }

# Sensor: extract prev ts, prev value
filter {
    if ([m] == "csr" and [s] and [ts]) {
        elasticsearch {
            hosts => ["elasticsearch:9200"]
            index => "logstash_hk-*"
            query => "m:csr AND s.id:%{[s_id]}"
            fields => { "ts" => "prev_ts_" "s_v" => "prev_s_v_" }
        }
        mutate { convert => { "prev_ts_" => "integer" "prev_s_v_" => "integer" } }
    }
}

# Sensor: calculate period for state sensor
filter {
    if ([m] == "csr" and [s] and [ts] and [sensor_type] == "state") {
        if ([s_v] != [prev_s_v_]) {
            if ([prev_ts_] and [ts] > [prev_ts_]) {
                ruby {
                    code => "event.set('period', (event.get('ts') - event.get('prev_ts_'))) rescue nil"
                }
            } else {
                elasticsearch {
                    hosts => ["elasticsearch:9200"]
                    index => "logstash_hk-*"
                    query => "m:csr AND s.id:%{[s_id]} AND s.v:%{[s_v]}"
                    fields => { "@timestamp" => "prev_timestamp" }
                }
                date {
                    match => ["[prev_timestamp]", "ISO8601"]
                    target => "[prev_timestamp]"
                }
                ruby {
                    code => "event.set('period', event.get('@timestamp') - event.get('prev_timestamp')) rescue nil"
                }
            }
        }
    }
}

# Calculate *_production fields
filter {
    # TODO
}

# Update csr_state
filter {
    if ([m] == "csr" and ([csr_type] == "node" or [sensor_type] == "state") and [ts] == [prev_ts_]) {
        mutate { replace => { "csr_state" => "outdated" } }
    }
}

# Add human-readable fields for sensor states
filter {
    if ([sensor_type] == "state") {
        if ([s_v] == 0) {
            mutate { add_field => { "state" => "false" "state_str" => "OFF" } }
        }
        if ([s_v] == 1) {
            mutate { add_field => { "state" => "true" "state_str" => "ON" } }
        }
    }
}

# Add human-readable fields for node state
filter {
    if ([n_ns] == 0) {
        mutate { add_field => { "state" => "false" "state_str" => "OFF" } }
    }
    if ([n_ns] == 1) {
        mutate { add_field => { "state" => "true" "state_str" => "ON" } }
    }
}

# Add human-readable names to nodes and sensors
filter {
    if ([n_id] == 22) {
        mutate { add_field => { "name" => "Supply" } }
    }
    if ([n_id] == 24) {
        mutate { add_field => { "name" => "Heating" } }
    }
    if ([n_id] == 26) {
        mutate { add_field => { "name" => "Floor" } }
    }
    if ([n_id] == 28) {
        mutate { add_field => { "name" => "Hot water" } }
    }
    if ([n_id] == 30) {
        mutate { add_field => { "name" => "Circulation" } }
    }
    if ([n_id] == 34) {
        mutate { add_field => { "name" => "Standby heater" } }
    }
    if ([n_id] == 36) {
        mutate { add_field => { "name" => "Solar Primay" } }
    }
    if ([n_id] == 38) {
        mutate { add_field => { "name" => "Solar Secondary" } }
    }

    if ([s_id] == 54) {
        mutate { add_field => { "name" => "Supply" } }
    }
    if ([s_id] == 55) {
        mutate { add_field => { "name" => "Reverse" } }
    }
    if ([s_id] == 56) {
        mutate { add_field => { "name" => "Tank" } }
    }
    if ([s_id] == 57) {
        mutate { add_field => { "name" => "Boiler" } }
    }
    if ([s_id] == 58) {
        mutate { add_field => { "name" => "Mix" } }
    }
    if ([s_id] == 59) {
        mutate { add_field => { "name" => "Standby heater" } }
    }
    if ([s_id] == 60) {
        mutate { add_field => { "name" => "Boiler Power" } }
    }
    if ([s_id] == 61) {
        mutate { add_field => { "name" => "Solar Primary" } }
    }
    if ([s_id] == 62) {
        mutate { add_field => { "name" => "Solar Secondary" } }
    }
    if ([s_id] == 74) {
        mutate { add_field => { "name" => "Room Temperature" } }
    }
    if ([s_id] == 75) {
        mutate { add_field => { "name" => "Room Humidity" } }
    }
}

# Remove temporary fields
filter {
    mutate {
        remove_field => [ "prev_ts_", "prev_s_v_", "prev_n_ns_", "type" ]
    }
}

output {
    elasticsearch {
        hosts => "elasticsearch:9200"
        index => "logstash_hk-%{+YYYY.MM.dd}"
        template => "/usr/share/logstash/config/template_hk.json"
        template_overwrite => "true"
    }
}

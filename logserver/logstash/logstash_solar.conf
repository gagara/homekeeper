input {
    exec {
        id => "current data"
        command => 'curl -s -X GET "http://${FRONIUS_HOST:localhost}:${FRONIUS_PORT:80}/solar_api/v1/GetInverterRealtimeData.cgi?Scope=Device&DeviceId=1&DataCollection=CommonInverterData"'
        interval => "${FRONIUS_CURR_RQ_PULL_INTERVAL:60}"
        codec => "json"
    }
    exec {
        id => "archive data"
        command => 'curl -s -X GET "http://${FRONIUS_HOST:localhost}:${FRONIUS_PORT:80}/solar_api/v1/GetArchiveData.cgi?Scope=Device&DeviceClass=Inverter&DeviceId=1&StartDate=$(date -u --date=@$(($(date -u +%s) - ${FRONIUS_ARCH_RQ_PULL_INTERVAL:300})) +%Y-%m-%dT%H:%M:%S)&EndDate=$(date -u +%Y-%m-%dT%H:%M:%S)&Channel=Current_DC_String_1&Channel=Current_DC_String_2&Channel=Voltage_DC_String_1&Channel=Voltage_DC_String_2&Channel=Voltage_AC_Phase_1&Channel=Current_AC_Phase_1&Channel=Temperature_Powerstage"'
        interval => "${FRONIUS_ARCH_RQ_PULL_INTERVAL:300}"
        codec => "json"
    }
}

# archive: split data by channel type
filter {
    if ([Head][RequestArguments][Channel]) {
        split {
            field => "[Head][RequestArguments][Channel]"
        }
    }
}

# archive: extract timestamp offsets
filter {
    if ([Head][RequestArguments][Channel] and [Body][Data][inverter/1][Data]) {
        ruby {
            code => "
                event.set('timestamp_offset_', event.get('[Body][Data][inverter/1][Data][%1$s][Values]' % [ event.get('[Head][RequestArguments][Channel]') ]).keys)
            "
        }
    }
}

# archive: split events by timestamp_offset_ array
filter {
    if ([Head][RequestArguments][Channel] and [timestamp_offset_]) {
        split {
            field => "[timestamp_offset_]"
        }
        mutate {
            convert => { "timestamp_offset_" => "integer" }
        }
    }
}

# archive: extract data for current timestamp offset and remove all others
filter {
    if ([Head][RequestArguments][Channel] and [timestamp_offset_]) {
        ruby {
            code => "
                event.set('[Body][Data][inverter/1][Unit]', event.get('[Body][Data][inverter/1][Data][%1$s][Unit]' % [ event.get('[Head][RequestArguments][Channel]') ]))
                event.set('[Body][Data][inverter/1][Value]', event.get('[Body][Data][inverter/1][Data][%1$s][Values][%2$s]' % [ event.get('[Head][RequestArguments][Channel]'), event.get('[timestamp_offset_]') ]))
            "
        }
        mutate {
            convert => { "[Body][Data][inverter/1][Value]" => "float" }
        }
        mutate {
            remove_field => [ "[Body][Data][inverter/1][Data]" ]
        }
    }
}

# archive: update @timestamp field based on current timestamp offset
filter {
    if ([Head][RequestArguments][Channel] and [Body][Data][inverter/1][Start] and [timestamp_offset_]) {
        date {
            match => [ "[Body][Data][inverter/1][Start]", "yyyy-MM-dd'T'HH:mm:ssZZ" ]
        }
        ruby {
            code => "
                event.set('timestamp_', event.get('@timestamp').to_i + event.get('timestamp_offset_'))
            "
        }
        mutate {
            convert => { "[timestamp_]" => "string" }
        }
        date {
            match => [ "[timestamp_]", "UNIX" ]
        }
    }
}

# archive: remove temporary fields
filter {
    mutate {
        remove_field => [ "[timestamp_offset_]", "[timestamp_]" ]
    }
}

# add inverter states description
filter {
    if ([Body][Data][DeviceStatus][StatusCode]) {
        translate {
            field => "[Body][Data][DeviceStatus][StatusCode]"
            destination => "[Body][Data][DeviceStatus][StatusCodeDescription]"
            dictionary => {
                "0" => "Startup-0"
                "1" => "Startup-1"
                "2" => "Startup-2"
                "3" => "Startup-3"
                "4" => "Startup-4"
                "5" => "Startup-5"
                "6" => "Startup-6"
                "7" => "Running"
                "8" => "Standby"
                "9" => "Bootloading"
                "10" => "Error"
            }
            fallback => "Status_%{[Body][Data][DeviceStatus][StatusCode]}"
        }
    }
}

# add inverter error codes description
filter {
    if ([Body][Data][DeviceStatus][ErrorCode]) {
        translate {
            field => "[Body][Data][DeviceStatus][ErrorCode]"
            destination => "[Body][Data][DeviceStatus][ErrorCodeDescription]"
            dictionary => {
                "0" => "OK"
                "102" => "AC voltage high"
                "103" => "AC voltage low"
                "105" => "AC freq high"
                "106" => "AC freq low"
                "107" => "AC grid out limits"
                "108" => "Standalone op detected"
                "112" => "RCMU error"
                "301" => "AC overcurrent"
                "302" => "DC overcurrent"
                "303" => "Inverter overtemperature (short)"
                "304" => "Inverter overtemperature (restart)"
                "306" => "Low PV output"
                "307" => "Low PV voltage"
                "308" => "Intermediate circuit overvoltage"
                "309" => "MPPT1 voltage high"
                "313" => "MPPT2 voltage high"
                "522" => "DC1 voltage low"
                "523" => "DC2 voltage low"
                "567" => "GVDPR"
            }
            fallback => "Error_%{[Body][Data][DeviceStatus][ErrorCode]}"
        }
    }
}

output {
    elasticsearch {
        hosts => "${ELASTICSEARCH_HOST:localhost}:${ELASTICSEARCH_PORT:9200}"
        index => "logstash_solar-%{+YYYY.MM.dd}"
        template => "/usr/share/logstash/config/template_solar.json"
        template_name => "solar"
        template_overwrite => "true"
    }
}
